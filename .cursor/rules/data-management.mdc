# Data Management Patterns

## Pagination Standards
Use the standardized pagination hook for consistent URL state management:

```typescript
// src/hooks/usePagination.ts pattern
export interface PaginationParams {
  page: number;
  pageSize: number;
  search: string;
}

export const useStandardPagination = (options: {
  defaultPageSize?: number;
  defaultPage?: number;
}) => {
  const searchParams = useSearchParams();
  const router = useRouter();
  const pathname = usePathname();

  const params = {
    page: parseInt(searchParams.get('page') || '1'),
    pageSize: parseInt(searchParams.get('pageSize') || String(options.defaultPageSize || 10)),
    search: searchParams.get('search') || '',
  };

  const updateURL = (newParams: Partial<PaginationParams>) => {
    const updatedParams = { ...params, ...newParams };
    const queryString = new URLSearchParams({
      page: String(updatedParams.page),
      pageSize: String(updatedParams.pageSize),
      ...(updatedParams.search ? { search: updatedParams.search } : {}),
    }).toString();
    
    router.push(`${pathname}?${queryString}`);
  };

  return {
    params,
    setPage: (page: number) => updateURL({ page }),
    setPageSize: (pageSize: number) => updateURL({ pageSize, page: 1 }),
    setSearch: (search: string) => updateURL({ search, page: 1 }),
  };
};
```

## Bulk Import Patterns
Implement consistent bulk import functionality using the template pattern:

```typescript
// Bulk import configuration interface
interface BulkImportConfig<TImport, TApi = TImport> {
  templateData: TImport[];
  templateFileName: string;
  acceptedFileTypes: string;
  columns: BulkImportColumn[];
  validateData: (data: any[]) => { errors: ValidationError[]; valid: TImport[] };
  transformData?: (data: TImport) => TApi;
  importData: (data: TApi[]) => Promise<ImportResult>;
}

// Validation error structure
interface ValidationError {
  row: number;
  field: string;
  message: string;
  value: unknown;
}

// Import result structure
interface ImportResult {
  success: number;
  failed: number;
  errors: Array<{ row: number; error: string }>;
}

// Example: User bulk import implementation
const BulkImportUsersPage = () => {
  const createUserMutation = useCreateUserMutation();

  const validateUserData = (data: any[]): { errors: ValidationError[]; valid: UserImportData[] } => {
    const errors: ValidationError[] = [];
    const valid: UserImportData[] = [];

    data.forEach((row, index) => {
      const rowNumber = index + 2;
      const validRow: Partial<UserImportData> = {};

      // Validate name
      if (!row.name || typeof row.name !== "string" || row.name.trim().length === 0) {
        errors.push({
          row: rowNumber,
          field: "name",
          message: "Name is required",
          value: row.name,
        });
      } else {
        validRow.name = row.name.trim();
      }

      // Validate email
      if (!row.email || typeof row.email !== "string" || !/^[^@]+@[^@]+\.[^@]+$/.test(row.email)) {
        errors.push({
          row: rowNumber,
          field: "email",
          message: "Valid email is required",
          value: row.email,
        });
      } else {
        validRow.email = row.email.trim();
      }

      // Validate status
      if (row.status !== 0 && row.status !== 1) {
        errors.push({
          row: rowNumber,
          field: "status",
          message: "Status must be 0 (Active) or 1 (Inactive)",
          value: row.status,
        });
      } else {
        validRow.status = Number(row.status);
      }

      if (validRow.name && validRow.email && typeof validRow.status === "number") {
        valid.push(validRow as UserImportData);
      }
    });

    return { errors, valid };
  };

  const importUserData = async (data: UserImportData[]): Promise<ImportResult> => {
    const results: ImportResult = { success: 0, failed: 0, errors: [] };

    for (let i = 0; i < data.length; i++) {
      try {
        // Transform import data to API format
        const userCreateData = {
          make: data[i].name,
          short_code: data[i].email,
          status: data[i].status === 0 ? "ACTIVE" : "DISABLED" as "ACTIVE" | "DISABLED"
        };
        
        await createUserMutation.mutateAsync(userCreateData);
        results.success++;
      } catch (error) {
        results.failed++;
        results.errors.push({
          row: i + 2,
          error: error instanceof Error ? error.message : "Unknown error occurred",
        });
      }
    }

    return results;
  };

  const config: BulkImportConfig<UserImportData> = {
    templateData: [
      { name: "John Doe", email: "john@example.com", status: 0 },
      { name: "Jane Smith", email: "jane@example.com", status: 1 },
    ],
    templateFileName: "users_template.xlsx",
    acceptedFileTypes: ".xlsx,.xls,.csv",
    columns: [
      { title: "Name", dataIndex: "name", key: "name" },
      { title: "Email", dataIndex: "email", key: "email" },
      { title: "Status", dataIndex: "status", key: "status" },
    ],
    validateData: validateUserData,
    importData: importUserData,
  };

  return (
    <CardWrapper title="Bulk Import Users">
      <BulkImportTemplate config={config} />
    </CardWrapper>
  );
};
```

## Data Transformation Patterns
Create type-safe transformation functions for data mapping:

```typescript
// Generic transformation function type
type TransformFunction<TInput, TOutput> = (input: TInput) => TOutput;

// Example: User import to API transformation
interface UserImportData {
  name: string;
  email: string;
  status: number; // 0 = Active, 1 = Inactive
}

interface UserCreateRequest {
  make: string;
  short_code: string;
  status: "ACTIVE" | "DISABLED";
}

const transformUserImportData: TransformFunction<UserImportData, UserCreateRequest> = (
  importData
) => ({
  make: importData.name,
  short_code: importData.email,
  status: importData.status === 0 ? "ACTIVE" : "DISABLED"
});

// Generic list transformation utility
const transformList = <TInput, TOutput>(
  items: TInput[],
  transform: TransformFunction<TInput, TOutput>
): TOutput[] => items.map(transform);

// Usage example
const transformedUsers = transformList(importUsers, transformUserImportData);
```

## Safe Data Access Patterns
Handle nested API responses safely:

```typescript
// Safe nested data access
const Dashboard: React.FC = () => {
  const { user, isLoadingUser, isAuthenticated } = useAuth();

  // Safe access with multiple fallbacks
  if (!isAuthenticated || !user || !user.data) {
    return <LoadingSpinner fullScreen />;
  }

  const userData = user.data;
  const displayName = userData.displayName || 
    `${userData.firstName || ''} ${userData.lastName || ''}`.trim() || 
    "User";

  return <h1>Welcome, {displayName}!</h1>;
};

// Safe data access for lists
const UsersPage: React.FC = () => {
  const { data, isLoading } = useUsersQuery(page, limit, search);
  
  // Safe access to paginated data
  const users = data?.data || [];
  const total = data?.total || 0;
  
  return (
    <Table 
      columns={columns} 
      data={users} 
      loading={isLoading}
      pagination={{ current: page, total, pageSize: limit }}
    />
  );
};
```

## Delete Action Patterns
Use centralized delete handling with confirmation:

```typescript
// Centralized delete handler utility
export async function handleDeleteAction({
  id,
  mutation,
  t,
  setToast,
  confirmTitle,
  confirmText,
  successMessage,
  errorMessage,
}: {
  id: number | string;
  mutation: (id: number | string) => Promise<any>;
  t: (key: string) => string;
  setToast: (toast: { show: boolean; message: string; variant: 'success' | 'danger' }) => void;
  confirmTitle?: string;
  confirmText?: string;
  successMessage?: string;
  errorMessage?: string;
}) {
  const confirmed = await confirmDialog({
    title: confirmTitle || t('confirmDelete'),
    text: confirmText || t('confirmText'),
    confirmButtonText: t('delete'),
    cancelButtonText: t('cancel'),
    icon: 'error',
  });

  if (!confirmed) return;

  try {
    await mutation(id);
    setToast({
      show: true,
      message: successMessage || t('messages.userDeleted'),
      variant: 'success',
    });
  } catch (err: any) {
    setToast({
      show: true,
      message: err?.message || errorMessage || t('messages.error'),
      variant: 'danger',
    });
  }
}

// Usage in component
const UsersPage = () => {
  const { mutateAsync: deleteUser } = useDeleteUserMutation();
  const [toast, setToast] = useState({ show: false, message: "", variant: "success" as const });

  const handleDelete = (id: number) =>
    handleDeleteAction({
      id,
      mutation: (id: string | number) => deleteUser(typeof id === 'string' ? parseInt(id) : id),
      t,
      setToast,
    });

  // Rest of component...
};
```

## Table Data Handling
Implement consistent table data patterns:

```typescript
// Generic table column definition
interface UITableColumn<T = any> {
  key: string;
  title: string;
  dataIndex?: string;
  width?: number | string;
  render?: (value: any, record: T, index: number) => React.ReactNode;
  align?: "left" | "center" | "right";
}

// Table implementation with proper typing
const UsersTable: React.FC = () => {
  const t = useTranslations('users');
  const { data, isLoading } = useUsersQuery(page, limit, search);
  const { mutateAsync: deleteUser } = useDeleteUserMutation();

  const users = data?.data || [];

  const columns: UITableColumn<User>[] = [
    { 
      key: "name", 
      title: t("name"), 
      dataIndex: "displayName",
      render: (_, record) => record.displayName || `${record.firstName} ${record.lastName}`.trim()
    },
    { key: "email", title: t("email"), dataIndex: "email" },
    {
      key: "actions",
      title: t("actions"),
      render: (_, record) => (
        <div className={styles.actionButtons}>
          <ActionButton
            icon={<Pencil width={16} />}
            variant="primary"
            onClick={() => handleEdit(record.id)}
          />
          <ActionButton
            icon={<Trash2 width={16} />}
            variant="danger"
            onClick={() => handleDelete(Number(record.id))}
          />
        </div>
      ),
    },
  ];

  return <Table columns={columns} data={users} loading={isLoading} />;
};
```

## File Upload Patterns
Implement consistent file upload handling:

```typescript
// File upload with validation
interface FileUploadProps {
  name: string;
  label?: string;
  accept?: string;
  multiple?: boolean;
  maxSize?: number; // in MB
  required?: boolean;
  onChange?: (files: File[]) => void;
  onError?: (errors: string[]) => void;
}

const FileUpload: React.FC<FileUploadProps> = ({
  accept = "*/*",
  multiple = false,
  maxSize = 10,
  onChange,
  onError,
  ...props
}) => {
  const handleFileChange = (files: FileList | null) => {
    if (!files) return;

    const fileArray = Array.from(files);
    const errors: string[] = [];

    // Validate files
    fileArray.forEach((file, index) => {
      if (file.size > maxSize * 1024 * 1024) {
        errors.push(`File ${index + 1}: Size exceeds ${maxSize}MB limit`);
      }
    });

    if (errors.length > 0) {
      onError?.(errors);
      return;
    }

    onChange?.(fileArray);
  };

  return (
    <div className={styles.fileUpload}>
      <input
        type="file"
        accept={accept}
        multiple={multiple}
        onChange={(e) => handleFileChange(e.target.files)}
        {...props}
      />
    </div>
  );
};
```

## Best Practices
- **Consistent Patterns**: Use standardized patterns across features
- **Type Safety**: Maintain strict typing for all data operations
- **Error Handling**: Implement comprehensive error handling and user feedback
- **Performance**: Use TanStack Query for efficient data caching and updates
- **Accessibility**: Ensure all data operations are accessible
- **Validation**: Implement robust client-side and server-side validation
- **User Experience**: Provide clear feedback for all data operations
description:
globs:
alwaysApply: false
---
