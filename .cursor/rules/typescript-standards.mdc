# TypeScript Coding Standards

## Code Style
- **Indentation**: 2 spaces
- **Quotes**: Single quotes for strings
- **Semicolons**: Always required
- **Trailing commas**: Use in objects and arrays
- **Line length**: 80 characters max (flexible for complex types)

## TypeScript Best Practices
- **Strict mode**: Always enabled in [tsconfig.json](mdc:tsconfig.json)
- **Interfaces**: Use for object shapes and props
- **Types**: Use for unions, intersections, and complex types
- **Generics**: Use for reusable components and functions
- **Never use `any`**: Use `unknown` or proper typing instead
- **Type suppression**: Use `// @ts-nocheck` sparingly, only for complex legacy components

**Interface vs Type: When to Use Each**

- **Use `interface`** for object shapes, data models, and component/class props—especially if you want to extend or implement them later.
- **Use `type`** for unions, intersections, utility types, mapped types, primitives, tuples, and function signatures.

| Use Case                        | `interface` | `type` |
|----------------------------------|:----------:|:------:|
| Object shapes                    |     ✔️      |   ✔️    |
| Class implementation             |     ✔️      |        |
| Extending (inheritance)          |     ✔️      |   ✔️    |
| Declaration merging              |     ✔️      |        |
| Unions/intersections             |            |   ✔️    |
| Primitives, tuples, functions    |            |   ✔️    |
| Utility/mapped types             |            |   ✔️    |

**Default:** Use `interface` for objects and props, `type` for everything else.

## API Response Type Patterns

### Nested Response Structure
Handle APIs with nested success/data structure:

```typescript
// Base nested response type
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// Auth response with nested user
interface AuthResponse {
  user: {
    success: boolean;
    data: User;
  };
  token: string;
  refreshToken?: string;
  expiresIn?: number;
}

// Paginated response
interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}
```

### Proper User Data Access
When working with nested user data:

```typescript
// Component handling nested user structure
const Dashboard: React.FC = () => {
  const { user } = useAuth(); // Returns { success: boolean; data: User }
  
  // Safe access to nested user data
  if (!user || !user.data) {
    return <LoadingSpinner />;
  }

  const userData = user.data;
  const displayName = userData.displayName || 
    `${userData.firstName || ''} ${userData.lastName || ''}`.trim() || 
    "User";

  return <h1>Welcome, {displayName}!</h1>;
};
```

## Import/Export Standards
- **Absolute imports**: Use `@/` prefix for src directory
- **Named exports**: Prefer named exports over default exports
- **Import order**: 
  1. React and Next.js imports
  2. Third-party libraries
  3. Internal components/hooks
  4. Utilities and constants
  5. Types and interfaces
  6. Styles

```typescript
import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { Button } from 'react-bootstrap';
import { User, Trash2 } from 'lucide-react';

import CardWrapper from '@/components/pure-components/CardWrapper';
import { useAuth } from '@/hooks/auth';
import { handleDeleteAction } from '@/utils/deleteHandler';
import { VALIDATION_MESSAGES } from '@/constants';

import type { User } from '@/types/auth';
import type { ComponentProps } from '@/types/ui';

import styles from './Component.module.scss';
```

## Component Patterns

### Props Interface with Proper Event Handling
```typescript
export interface ComponentNameProps {
  // Required props
  title: string;
  
  // Optional props with defaults
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  
  // Event handlers with proper types
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
  onChange?: (value: string) => void;
  onDelete?: (id: number | string) => void;
  
  // Data props
  data?: User[];
  loading?: boolean;
  
  // Styling
  className?: string;
  
  // Content
  children?: React.ReactNode;
}
```

### Data Transformation Functions
```typescript
// Type-safe data transformation
type TransformFunction<TInput, TOutput> = (input: TInput) => TOutput;

const transformUserImportData: TransformFunction<UserImportData, UserCreateRequest> = (
  importData
) => ({
  make: importData.name,
  short_code: importData.email,
  status: importData.status === 0 ? "ACTIVE" : "DISABLED"
});

// Generic transformation utility
const transformList = <TInput, TOutput>(
  items: TInput[],
  transform: TransformFunction<TInput, TOutput>
): TOutput[] => items.map(transform);
```

## Form and Validation Types
```typescript
// Form data with validation
interface UserFormData {
  name: string;
  email: string;
  status: number;
}

// Validation error structure
interface ValidationError {
  row: number;
  field: string;
  message: string;
  value: unknown;
}

// Import result interface
interface ImportResult {
  success: number;
  failed: number;
  errors: Array<{ row: number; error: string }>;
}
```

## Hook Return Types
```typescript
// Custom hook with proper return type
interface UseAuthReturn {
  user: AuthResponse["user"] | null;
  isLoadingUser: boolean;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => void;
  logout: () => void;
  isLoggingIn: boolean;
  isLoggingOut: boolean;
  loginError: Error | null;
  userError: Error | null;
}

export const useAuth = (): UseAuthReturn => {
  // Implementation
};
```

## Table and UI Component Types
```typescript
// Table column definition
interface UITableColumn<T = any> {
  key: string;
  title: string;
  dataIndex?: string;
  width?: number | string;
  fixed?: "left" | "right";
  sortable?: boolean;
  filterable?: boolean;
  render?: (value: any, record: T, index: number) => React.ReactNode;
  align?: "left" | "center" | "right";
}

// Generic table props
interface UITableProps<T = any> {
  columns: UITableColumn<T>[];
  data: T[];
  loading?: boolean;
  pagination?: {
    current: number;
    pageSize: number;
    total: number;
    onChange: (page: number, pageSize: number) => void;
  };
}
```

## Error Handling Types
```typescript
// API error structure
interface ApiError extends Error {
  status?: number;
  code?: string;
  details?: unknown;
}

// Component error boundary
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}
```

## Example Component Structure
```typescript
import React from 'react';
import { Button as BootstrapButton } from 'react-bootstrap';
import { Loader2 } from 'lucide-react';
import styles from './Button.module.scss';

export interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  disabled?: boolean;
  children?: React.ReactNode;
  className?: string;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled = false,
  children,
  className = '',
  onClick,
}) => {
  const isDisabled = disabled || loading;

  return (
    <BootstrapButton
      variant={variant}
      size={size}
      disabled={isDisabled}
      className={`${styles.button} ${className}`}
      onClick={onClick}
    >
      {loading && <Loader2 className={styles.spinner} size={16} />}
      {children}
    </BootstrapButton>
  );
};

export default Button;
```

## Migration and Compatibility
- **Gradual typing**: Migrate from `any` to proper types incrementally
- **Type assertions**: Use sparingly and with caution
- **Legacy components**: Use `// @ts-nocheck` for complex legacy components
- **Type guards**: Implement proper type guards for runtime checks

```typescript
// Type guard example
const isUser = (obj: unknown): obj is User => {
  return typeof obj === 'object' && 
         obj !== null && 
         'id' in obj && 
         'email' in obj;
};
```
