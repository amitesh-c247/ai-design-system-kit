# Performance Optimization Standards

## Next.js 15 Optimization Patterns
Leverage Next.js 15 features for optimal performance:

```typescript
// App Router with proper loading and error boundaries
// src/app/(view)/users/loading.tsx
export default function Loading() {
  return <LoadingSpinner fullScreen />;
}

// src/app/(view)/users/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="error-page">
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}

// Dynamic imports for code splitting
const BulkImportTemplate = dynamic(
  () => import('@/components/bulk-import/BulkImportTemplate'),
  {
    loading: () => <LoadingSpinner />,
    ssr: false, // Disable SSR for client-only components
  }
);
```

## Component Performance Optimization

### React.memo for Expensive Components
```typescript
import React, { memo, useMemo } from 'react';

interface TableRowProps {
  user: User;
  onEdit: (id: number) => void;
  onDelete: (id: number) => void;
}

// Memoize expensive table rows
const TableRow = memo<TableRowProps>(({ user, onEdit, onDelete }) => {
  // Memoize expensive computations
  const displayName = useMemo(() => {
    return user.displayName || 
      `${user.firstName || ''} ${user.lastName || ''}`.trim() || 
      'Unknown User';
  }, [user.displayName, user.firstName, user.lastName]);

  const handleEdit = useCallback(() => onEdit(user.id), [onEdit, user.id]);
  const handleDelete = useCallback(() => onDelete(user.id), [onDelete, user.id]);

  return (
    <tr>
      <td>{displayName}</td>
      <td>{user.email}</td>
      <td>
        <Button onClick={handleEdit}>Edit</Button>
        <Button onClick={handleDelete} variant="danger">Delete</Button>
      </td>
    </tr>
  );
});

TableRow.displayName = 'TableRow';
```

### Virtualized Lists for Large Data Sets
```typescript
import { FixedSizeList as List } from 'react-window';

interface VirtualizedTableProps {
  users: User[];
  height: number;
  itemHeight: number;
}

const VirtualizedTable: React.FC<VirtualizedTableProps> = ({
  users,
  height,
  itemHeight,
}) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
    const user = users[index];
    
    return (
      <div style={style}>
        <TableRow user={user} onEdit={handleEdit} onDelete={handleDelete} />
      </div>
    );
  };

  return (
    <List
      height={height}
      itemCount={users.length}
      itemSize={itemHeight}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

## TanStack Query Optimization

### Query Configuration for Performance
```typescript
// Optimized query configuration
export const useUsersQuery = (page: number, limit: number, search: string = "") => {
  return useQuery({
    queryKey: ['users', page, limit, search],
    queryFn: () => userService.getUsers(page, limit, search),
    staleTime: 1000 * 60 * 5, // 5 minutes
    gcTime: 1000 * 60 * 10, // 10 minutes (was cacheTime in v4)
    refetchOnWindowFocus: false,
    refetchOnMount: 'always',
    retry: (failureCount, error) => {
      if ((error as any)?.status === 404) return false;
      return failureCount < 3;
    },
    // Enable background refetch for better UX
    refetchInterval: 1000 * 60 * 5, // 5 minutes for live data
    enabled: true,
  });
};

// Prefetch related data
export const usePrefetchUserData = () => {
  const queryClient = useQueryClient();

  const prefetchUsers = useCallback(async (page: number, limit: number) => {
    await queryClient.prefetchQuery({
      queryKey: ['users', page, limit, ''],
      queryFn: () => userService.getUsers(page, limit, ''),
      staleTime: 1000 * 60 * 5,
    });
  }, [queryClient]);

  return { prefetchUsers };
};
```

### Optimistic Updates
```typescript
export const useCreateUserMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: userService.createUser,
    onMutate: async (newUser) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['users'] });

      // Snapshot previous value
      const previousUsers = queryClient.getQueryData(['users']);

      // Optimistically update
      queryClient.setQueryData(['users'], (old: any) => {
        if (!old) return old;
        return {
          ...old,
          data: [{ ...newUser, id: Date.now() }, ...old.data],
          total: old.total + 1,
        };
      });

      return { previousUsers };
    },
    onError: (err, newUser, context) => {
      // Rollback on error
      if (context?.previousUsers) {
        queryClient.setQueryData(['users'], context.previousUsers);
      }
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
};
```

## Image and Asset Optimization

### Next.js Image Component
```typescript
import Image from 'next/image';

// Optimized image component
const UserAvatar: React.FC<{ user: User; size?: number }> = ({ user, size = 40 }) => {
  return (
    <Image
      src={user.avatar || '/default-avatar.png'}
      alt={`${user.displayName} avatar`}
      width={size}
      height={size}
      className="rounded-circle"
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAhEAACAQMDBQAAAAAAAAAAAAABAgMABAUGIWGRkqGx0f/EABQBAQAAAAAAAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k="
      priority={size > 100} // Priority load for large avatars
      sizes="(max-width: 768px) 40px, 80px"
    />
  );
};

// Preload critical images
const HomePage = () => {
  useEffect(() => {
    // Preload critical images
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'image';
    link.href = '/hero-image.jpg';
    document.head.appendChild(link);
  }, []);

  return <div>...</div>;
};
```

## Bundle Optimization

### Dynamic Imports for Large Components
```typescript
// Lazy load heavy components
const LazyDataVisualization = dynamic(
  () => import('@/components/DataVisualization'),
  {
    loading: () => <div>Loading chart...</div>,
    ssr: false,
  }
);

const LazyMarkdownEditor = dynamic(
  () => import('@/components/MarkdownEditor'),
  {
    loading: () => <div>Loading editor...</div>,
    ssr: false,
  }
);

// Code splitting by route
const AdminPanel = dynamic(
  () => import('@/components/AdminPanel'),
  {
    loading: () => <LoadingSpinner />,
  }
);
```

### Tree Shaking Optimization
```typescript
// Good: Import only what you need
import { format, parseISO } from 'date-fns';
import { debounce } from 'lodash-es';

// Bad: Importing entire library
// import * as dateFns from 'date-fns';
// import _ from 'lodash';

// Use barrel exports carefully
// src/components/index.ts - Be selective
export { Button } from './Button';
export { Table } from './Table';
export { Form } from './Form';
// Don't export everything with export * from './ComponentName';
```

## State Management Optimization

### Efficient State Updates
```typescript
const useOptimizedState = <T>(initialState: T) => {
  const [state, setState] = useState(initialState);
  
  // Batch state updates
  const updateState = useCallback((updates: Partial<T>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  // Debounced updates for search
  const debouncedUpdate = useMemo(
    () => debounce((updates: Partial<T>) => updateState(updates), 300),
    [updateState]
  );

  return { state, updateState, debouncedUpdate };
};

// Context optimization
const UserContext = createContext<UserContextValue | null>(null);

const UserProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // Split context into multiple providers to prevent unnecessary re-renders
  const [user, setUser] = useState<User | null>(null);
  const [permissions, setPermissions] = useState<Permission[]>([]);

  // Memoize context value to prevent re-renders
  const value = useMemo(
    () => ({ user, setUser, permissions, setPermissions }),
    [user, permissions]
  );

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};
```

## Database Query Optimization

### Efficient Data Fetching
```typescript
// Implement pagination properly
const useOptimizedUsersQuery = (params: {
  page: number;
  limit: number;
  search?: string;
  filters?: UserFilters;
}) => {
  // Use stable query key
  const queryKey = useMemo(
    () => ['users', params.page, params.limit, params.search, params.filters],
    [params]
  );

  return useQuery({
    queryKey,
    queryFn: () => userService.getUsers(params),
    keepPreviousData: true, // Keep previous data while fetching new
    staleTime: 1000 * 60 * 5,
  });
};

// Implement cursor-based pagination for large datasets
const useInfiniteUsers = () => {
  return useInfiniteQuery({
    queryKey: ['users', 'infinite'],
    queryFn: ({ pageParam = 0 }) => userService.getUsersInfinite(pageParam),
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.hasMore ? allPages.length : undefined;
    },
    staleTime: 1000 * 60 * 5,
  });
};
```

## Performance Monitoring

### Core Web Vitals Monitoring
```typescript
// Monitor performance metrics
export function reportWebVitals(metric: any) {
  switch (metric.name) {
    case 'CLS':
      console.log('Cumulative Layout Shift:', metric.value);
      break;
    case 'FID':
      console.log('First Input Delay:', metric.value);
      break;
    case 'FCP':
      console.log('First Contentful Paint:', metric.value);
      break;
    case 'LCP':
      console.log('Largest Contentful Paint:', metric.value);
      break;
    case 'TTFB':
      console.log('Time to First Byte:', metric.value);
      break;
    default:
      break;
  }

  // Send to analytics service
  if (process.env.NODE_ENV === 'production') {
    // analytics.track('web-vital', metric);
  }
}

// Performance observer
const usePerformanceMonitor = () => {
  useEffect(() => {
    if (typeof window !== 'undefined' && 'PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'navigation') {
            console.log('Page load time:', entry.duration);
          }
        });
      });

      observer.observe({ entryTypes: ['navigation', 'measure'] });

      return () => observer.disconnect();
    }
  }, []);
};
```

## CSS and Styling Optimization

### Efficient SCSS Modules
```scss
// Component.module.scss - Optimize CSS
.component {
  // Use CSS custom properties for theming
  background-color: var(--background-color);
  color: var(--text-color);
  
  // Minimize nesting (max 3 levels)
  &:hover {
    background-color: var(--hover-background);
  }
  
  // Use efficient selectors
  .title {
    font-weight: 600;
  }
  
  // Avoid complex selectors
  // Bad: .component .nested .deep .selector
  // Good: .specificClass
}

// Use CSS containment for performance
.isolatedComponent {
  contain: layout style paint;
}
```

## Best Practices Summary
- **Code Splitting**: Use dynamic imports for large components and routes
- **Memoization**: Use React.memo, useMemo, and useCallback strategically
- **Query Optimization**: Configure TanStack Query for optimal caching and refetching
- **Image Optimization**: Use Next.js Image component with proper sizing
- **Bundle Analysis**: Regularly analyze and optimize bundle size
- **Performance Monitoring**: Track Core Web Vitals and user experience metrics
- **State Management**: Minimize re-renders with efficient state patterns
- **CSS Optimization**: Use efficient selectors and CSS containment
description:
globs:
alwaysApply: false
---
